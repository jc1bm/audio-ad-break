<script defer>
  async function createAdBreak() {
    const files = [
      document.getElementById('station').value,
      document.getElementById('ad1').value,
      document.getElementById('ad2').value,
      document.getElementById('ad3').value
    ];
    const imagePath = document.getElementById('image').value;
    const exportAsVideo = document.getElementById('exportAsVideo').checked;

    const audioCtx = new AudioContext();

    async function fetchAndDecode(url) {
      const res = await fetch(url);
      const arrayBuffer = await res.arrayBuffer();
      return await audioCtx.decodeAudioData(arrayBuffer);
    }

    const audioBuffers = await Promise.all(files.map(fetchAndDecode));
    const totalLength = audioBuffers.reduce((sum, b) => sum + b.length, 0);
    const outputBuffer = audioCtx.createBuffer(1, totalLength, audioCtx.sampleRate);

    let offset = 0;
    audioBuffers.forEach(buffer => {
      outputBuffer.getChannelData(0).set(buffer.getChannelData(0), offset);
      offset += buffer.length;
    });

    if (exportAsVideo) {
      const canvas = document.getElementById('videoCanvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.src = imagePath;

      await new Promise(resolve => img.onload = resolve);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      const canvasStream = canvas.captureStream();
      const audioDest = audioCtx.createMediaStreamDestination();

      const source = audioCtx.createBufferSource();
      source.buffer = outputBuffer;
      source.connect(audioDest);
      source.start();

      const combinedStream = new MediaStream([
        ...canvasStream.getVideoTracks(),
        ...audioDest.stream.getAudioTracks()
      ]);

      const recorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm' });
      const chunks = [];

      recorder.ondataavailable = e => chunks.push(e.data);
      recorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'ad-break.webm';
        a.click();
      };

      recorder.start();

      const duration = outputBuffer.duration * 1000;
      setTimeout(() => recorder.stop(), duration + 500);
    } else {
      // Export WAV
      const wavBlob = bufferToWav(outputBuffer);
      const url = URL.createObjectURL(wavBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ad-break.wav';
      a.click();
    }
  }

  function bufferToWav(buffer) {
    const numOfChan = buffer.numberOfChannels;
    const length = buffer.length * numOfChan * 2 + 44;
    const arrayBuffer = new ArrayBuffer(length);
    const view = new DataView(arrayBuffer);
    let offset = 0;

    function writeString(str) {
      for (let i = 0; i < str.length; i++) {
        view.setUint8(offset++, str.charCodeAt(i));
      }
    }

    const sampleRate = buffer.sampleRate;

    writeString('RIFF');
    view.setUint32(offset, length - 8, true); offset += 4;
    writeString('WAVE');
    writeString('fmt ');
    view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, 1, true); offset += 2;
    view.setUint16(offset, numOfChan, true); offset += 2;
    view.setUint32(offset, sampleRate, true); offset += 4;
    view.setUint32(offset, sampleRate * 2 * numOfChan, true); offset += 4;
    view.setUint16(offset, numOfChan * 2, true); offset += 2;
    view.setUint16(offset, 16, true); offset += 2;
    writeString('data');
    view.setUint32(offset, length - 44, true); offset += 4;

    for (let i = 0; i < buffer.length; i++) {
      for (let c = 0; c < numOfChan; c++) {
        const sample = buffer.getChannelData(c)[i];
        const s = Math.max(-1, Math.min(1, sample));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        offset += 2;
      }
    }

    return new Blob([arrayBuffer], { type: 'audio/wav' });
  }
</script>
